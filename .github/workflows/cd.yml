name: CD - Deploy to Azure AKS

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      deployment_mode:
        description: 'Deployment mode (azure for managed services, onprem for in-cluster)'
        required: true
        type: choice
        options:
          - azure
          - onprem
        default: 'azure'

env:
  AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}

jobs:
  check-branch:
    name: Check Branch and Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      branch: ${{ steps.determine-env.outputs.branch }}
      should_deploy: ${{ steps.determine-env.outputs.should_deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine environment from branch
        id: determine-env
        run: |
          # For manual workflow dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "branch=manual" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # For tag push, determine which branch the tag is on
          TAG="${GITHUB_REF#refs/tags/}"
          echo "Processing tag: $TAG"

          # Find which branch contains this tag
          BRANCHES=$(git branch -r --contains "$TAG" | grep -E 'origin/(main|staging|dev)' | sed 's/.*origin\///')

          if [[ -z "$BRANCHES" ]]; then
            echo "âŒ Tag $TAG is not on any of the allowed branches (main, staging, dev)"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Determine environment based on branch
          if echo "$BRANCHES" | grep -q "^main$"; then
            ENV="prod"
            BRANCH="main"
          elif echo "$BRANCHES" | grep -q "^staging$"; then
            ENV="staging"
            BRANCH="staging"
          elif echo "$BRANCHES" | grep -q "^dev$"; then
            ENV="dev"
            BRANCH="dev"
          else
            echo "âŒ Tag $TAG is not on any of the allowed branches (main, staging, dev)"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "âœ… Tag $TAG found on branch: $BRANCH"
          echo "ðŸŽ¯ Deploying to environment: $ENV"
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT

  build-and-push:
    name: Build and Push Docker Images
    needs: check-branch
    if: needs.check-branch.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Extract metadata
        id: meta
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
          else
            TAG=main-${GITHUB_SHA::8}
          fi
          echo "tags=$TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=$TAG" >> $GITHUB_ENV

      - name: Build and push Backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-saas-backend:${{ env.IMAGE_TAG }}
            ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-saas-backend:latest
          cache-from: type=registry,ref=${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-saas-backend:latest
          cache-to: type=inline

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-saas-frontend:${{ env.IMAGE_TAG }}
            ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-saas-frontend:latest
          cache-from: type=registry,ref=${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-saas-frontend:latest
          cache-to: type=inline

      - name: Scan Backend image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-saas-backend:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'backend-trivy-results.sarif'

      - name: Scan Frontend image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/ai-saas-frontend:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'frontend-trivy-results.sarif'

  deploy-to-aks:
    name: Deploy to AKS
    needs: [check-branch, build-and-push]
    if: needs.check-branch.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.check-branch.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment mode and environment
        id: set-env
        run: |
          # Environment is determined by check-branch job
          ENV="${{ needs.check-branch.outputs.environment }}"
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "DEPLOY_ENV=$ENV" >> $GITHUB_ENV

          echo "ðŸ“¦ Deploying to environment: $ENV"
          echo "ðŸŒ¿ From branch: ${{ needs.check-branch.outputs.branch }}"

          # Set deployment mode (default to secret if not provided)
          if [[ "${{ github.event.inputs.deployment_mode }}" != "" ]]; then
            MODE="${{ github.event.inputs.deployment_mode }}"
          else
            MODE="${{ secrets.DEPLOYMENT_MODE }}"
          fi
          MODE="${MODE:-azure}"  # Default to azure if not set
          echo "deployment_mode=$MODE" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_MODE=$MODE" >> $GITHUB_ENV

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Create namespaces if not exists
        run: |
          kubectl apply -f infra/k8s/namespaces/namespaces.yaml

      - name: Create/Update secrets
        run: |
          # Backend secrets
          kubectl create secret generic backend-secrets \
            --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            --from-literal=JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}" \
            --from-literal=POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
            --from-literal=AI_API_KEY="${{ secrets.AI_API_KEY }}" \
            --from-literal=AI_API_URL="${{ secrets.AI_API_URL }}" \
            --from-literal=REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}" \
            --namespace=app-backend \
            --dry-run=client -o yaml | kubectl apply -f -

          # Azure services secrets (only for Azure mode)
          if [[ "${{ env.DEPLOYMENT_MODE }}" == "azure" ]]; then
            kubectl create secret generic azure-services-secrets \
              --from-literal=AZURE_POSTGRES_HOST="${{ secrets.AZURE_POSTGRES_HOST }}" \
              --from-literal=AZURE_POSTGRES_PASSWORD="${{ secrets.AZURE_POSTGRES_PASSWORD }}" \
              --from-literal=AZURE_REDIS_HOST="${{ secrets.AZURE_REDIS_HOST }}" \
              --from-literal=AZURE_REDIS_KEY="${{ secrets.AZURE_REDIS_KEY }}" \
              --from-literal=AZURE_STORAGE_CONNECTION_STRING="${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" \
              --namespace=app-backend \
              --dry-run=client -o yaml | kubectl apply -f -
          fi

          # Monitoring secrets
          kubectl create secret generic monitoring-secrets \
            --from-literal=WORKSPACE_ID="${{ secrets.AZURE_LOG_ANALYTICS_WORKSPACE_ID }}" \
            --from-literal=WORKSPACE_KEY="${{ secrets.AZURE_LOG_ANALYTICS_WORKSPACE_KEY }}" \
            --namespace=shared \
            --dry-run=client -o yaml | kubectl apply -f -

          # Monitoring basic auth
          echo "${{ secrets.MONITORING_PASSWORD }}" | htpasswd -ci auth admin
          kubectl create secret generic monitoring-basic-auth \
            --from-file=auth \
            --namespace=shared \
            --dry-run=client -o yaml | kubectl apply -f -
          rm -f auth

      - name: Deploy to AKS
        run: |
          export IMAGE_TAG="${{ needs.build-and-push.outputs.image_tag }}"
          export AZURE_CONTAINER_REGISTRY="${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io"

          echo "Deploying in ${{ env.DEPLOYMENT_MODE }} mode..."

          if [[ "${{ env.DEPLOYMENT_MODE }}" == "onprem" ]]; then
            echo "ðŸ“¦ Deploying on-premise infrastructure..."

            # Deploy PostgreSQL and Redis in-cluster
            envsubst < infra/k8s/base/postgres-deployment.yaml | kubectl apply -f -
            envsubst < infra/k8s/base/redis-deployment.yaml | kubectl apply -f -

            # Wait for database
            echo "â³ Waiting for PostgreSQL..."
            kubectl wait --for=condition=ready pod -l app=postgres -n app-backend --timeout=300s

            echo "â³ Waiting for Redis..."
            kubectl wait --for=condition=ready pod -l app=redis -n app-backend --timeout=120s

            # Apply on-premise config
            kubectl apply -f infra/k8s/overlays/onprem/backend-config.yaml
          else
            echo "ðŸŒ©ï¸  Using Azure managed services..."

            # Apply Azure config
            kubectl apply -f infra/k8s/overlays/azure/backend-config.yaml
          fi

          # Deploy backend application
          echo "ðŸ”§ Deploying backend application..."
          envsubst < infra/k8s/base/backend-deployment.yaml | kubectl apply -f -

          # Deploy frontend (app-frontend namespace)
          echo "ðŸŽ¨ Deploying frontend..."
          envsubst < infra/k8s/base/frontend-deployment.yaml | kubectl apply -f -

          # Deploy monitoring stack (shared namespace)
          echo "ðŸ“Š Deploying monitoring stack..."
          kubectl apply -f infra/k8s/monitoring/fluent-bit/
          kubectl apply -f infra/k8s/monitoring/prometheus/

          # Apply ingress if production
          if [[ "${{ env.DEPLOY_ENV }}" == "prod" ]]; then
            echo "ðŸŒ Deploying ingress..."
            kubectl apply -f infra/k8s/base/ingress.yaml
          fi

      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/backend -n app-backend --timeout=5m
          kubectl rollout status deployment/frontend -n app-frontend --timeout=5m
          kubectl rollout status deployment/prometheus -n shared --timeout=5m

      - name: Run database migrations
        run: |
          # Only run migrations for on-premise mode (Azure PostgreSQL should be pre-configured)
          if [[ "${{ env.DEPLOYMENT_MODE }}" == "onprem" ]]; then
            echo "ðŸ—„ï¸  Running database migrations..."
            POD=$(kubectl get pod -n app-backend -l app=backend -o jsonpath="{.items[0].metadata.name}")
            kubectl exec -n app-backend $POD -- python scripts/init_db.py || true
          else
            echo "â„¹ï¸  Skipping migrations (Azure PostgreSQL should be pre-configured)"
          fi

      - name: Verify deployment
        run: |
          echo "=== app-backend namespace ==="
          kubectl get pods -n app-backend
          kubectl get services -n app-backend
          echo ""
          echo "=== app-frontend namespace ==="
          kubectl get pods -n app-frontend
          kubectl get services -n app-frontend
          echo ""
          echo "=== shared namespace (monitoring) ==="
          kubectl get pods -n shared
          kubectl get services -n shared
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n app-frontend
          kubectl get ingress -n shared

      - name: Send deployment notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Deployment to ${{ env.DEPLOY_ENV }} ${{ job.status }}
            Deployment Mode: ${{ env.DEPLOYMENT_MODE }}
            Image Tag: ${{ needs.build-and-push.outputs.image_tag }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  rollback:
    name: Rollback Deployment
    needs: [check-branch, build-and-push, deploy-to-aks]
    if: failure() && needs.check-branch.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Rollback Backend
        run: |
          kubectl rollout undo deployment/backend -n app-backend

      - name: Rollback Frontend
        run: |
          kubectl rollout undo deployment/frontend -n app-frontend

      - name: Verify rollback
        run: |
          kubectl rollout status deployment/backend -n app-backend
          kubectl rollout status deployment/frontend -n app-frontend
